# examples

## Aho_Corasic

> Алгоритм Ахо-Корасик поиска подстрок в строке.

Для сборки программы воспользуйтесь утилитой `make`. Для сборки тестирования &ndash; `make test`.

Запуск программы осуществляется следующим образом: `./program`. Прграмма принимает на вход строку-шаблон, затем количество строк-поиска и сами строки поиска. На выходе &ndash; позиция строки-поиска в шаблоне и номер строки-поиска (нумерация с 1). Например:
```
> ./program
```
Входные данные:
```
ABAABB
3
AB
BA
ABC
```
Выходные данные:
```
1 1
2 2
4 1
```

Программа нашла строку "AB" на 1 и 4 позициях, а строку "BA" &ndash; на второй.

Для удобства использования реализован CLI-интерфейс. Для ознакомления необходимо ввести `./program --help`.

Помимо прочего, программа способна удалять найденные подстроки (запуск с ключом `-e` или `--erase`), вычислять максимальное количество исходящих из одной вершины дуг (запуск с ключом `-m` или `--max`). Также, имеется режим поиска в строке подстроки с символом-джокером (символ вне алфавита). Для этого на вход подаётся строка-шаблон, строка-поиска, содержащая символ-джокер, и сам символ-джокер. Для запуска программы в таком режиме необходимо запускать с ключом `-j` или `--joker`. Пример:

```
> ./program -j
```
Входные данные:
```
NACGNTTACGGTCACNN
AC$$T$AC$$
$
```
Выходные данные:
```
2
8
```

## FFA

> Поиск максимального потока в ориентированном графе алгоритмом Форда-Фалкерсона.

Для сборки программы воспользуйтесь утилитой `make`. Для сборки тестирования &ndash; `make test`.

Запуск программы осуществляется следующим образом: `./program`. Прграмма принимает на вход количество дуг графа, начальную вершину (исток), конечную вершину (сток) и список дуг (начало дуги, конец дуги и вес (пропускная способность) дуги). На выходе &ndash; максимальный поток и поток через каждую дугу. Например:
```
> ./program
```
Входные данные:
```
3
a
c
a b 1
b c 2
a c 3
```
Выходные данные:
```
4
a b 1
a c 3
b c 1
```

Для удобства использования реализован CLI-интерфейс. Для ознакомления необходимо ввести `./program --help`.

## Huffman_coding

> Динамический метод кодирования и декодирования по Хаффману.

Для сборки программы воспользуйтесь утилитой `make`. Для тестирования необходимо сперва собрать программу, а затем запустить python-скрипт: `python3 test.py`.

Программа работает в двух режимах: кодирования и декодирования.

Запуск программы в режиме кодирования осуществляется следующим образом: `./program --encode`. Прграмма принимает на вход строку и выдаёт закодированный двоичный код. Программа может выдать результат в восьмиричной и в шестнадцатиричной системе счисления. Для этого необходимо запустить программу следующим образом: `./program --encode=8` или `./program --encode=16` соответственно. Например:
```
> ./program --encode
```
Входные данные:
```
Hello
```
Выходные данные:
```
01001000001100101000110110010110001101111
```

Запуск программы в режиме декодирования осуществляется следующим образом: `./program --decode`. Прграмма принимает на вход двоичный код и выдаёт расшифрованную строку. Например:
```
> ./program --decode
```
Входные данные:
```
01001000001100101000110110010110001101111
```
Выходные данные:
```
Hello
```

Для удобства использования реализован CLI-интерфейс. Для ознакомления необходимо ввести `./program --help`.

Помимо прочего, программа способна способна визуализировать работу алгоритма. Для этого необходимо запустить программу с ключом `--debug`. Пример:

```
> ./program --encode --debug
```
Входные данные:
```
Cat
```
Выходные данные:
```
1. Encoding 'C'...
'C' is not in the tree. Adding...

	'C'(1)
   (1)
	 * (0)

'C' -> 01000011
Normalizing...

	'C'(1)
   (1)
	 * (0)

	 ||
	\  /
	 \/

2. Encoding 'a'...
'a' is not in the tree. Adding...

	'C'(1)
   (2)
		'a'(1)
	   (1)
		 * (0)

'a' -> 001100001
Normalizing...

	'C'(1)
   (2)
		'a'(1)
	   (1)
		 * (0)

	 ||
	\  /
	 \/

3. Encoding 't'...
't' is not in the tree. Adding...

	'C'(1)
   (3)
		'a'(1)
	   (2)
			't'(1)
		   (1)
			 * (0)

't' -> 0001110100
Normalizing...

		'a'(1)
	   (2)
			't'(1)
		   (1)
			 * (0)
   (3)
	'C'(1)

1.	'C'	01000011
2.	'a'	001100001
3.	't'	0001110100

010000110011000010001110100
```

```
> ./program --decode --debug
```
Входные данные:
```
010000110011000010001110100
```
Выходные данные:
```
Decoding...

 * (0)

1. 01000011 -> 'C'
'C' is not in the tree. Adding...

	'C'(1)
   (1)
	 * (0)

Normalizing...

	'C'(1)
   (1)
	 * (0)

	 ||
	\  /
	 \/

2. 001100001 -> 'a'
'a' is not in the tree. Adding...

	'C'(1)
   (2)
		'a'(1)
	   (1)
		 * (0)

Normalizing...

	'C'(1)
   (2)
		'a'(1)
	   (1)
		 * (0)

	 ||
	\  /
	 \/

3. 0001110100 -> 't'
't' is not in the tree. Adding...

	'C'(1)
   (3)
		'a'(1)
	   (2)
			't'(1)
		   (1)
			 * (0)

Normalizing...

		'a'(1)
	   (2)
			't'(1)
		   (1)
			 * (0)
   (3)
	'C'(1)

1.	'C'	01000011
2.	'a'	001100001
3.	't'	0001110100

Cat
```

## KMP

> Алгоритм Кнута-Морриса-Пратта поиска подстроки в строке.

Для сборки программы воспользуйтесь утилитой `make`. Для сборки тестирования &ndash; `make test`.

Запуск программы осуществляется следующим образом: `./program`. Прграмма принимает на вход подстроку, затем строку для поиска. На выходе &ndash; позиции подстроки в строке (нумерация с 0) или -1, если подстрока не найдена. Например:
```
> ./program
```
Входные данные:
```
ab
abacaba
```
Выходные данные:
```
0, 4
```

Для удобства использования реализован CLI-интерфейс. Для ознакомления необходимо ввести `./program --help`.

Помимо прочего, программа способна определять, является ли первая строка циклическим сдвигом второй. Для этого необходимо запустить программу с ключом `-c` или `--cycle` Пример:

```
> ./program --cycle
```
Входные данные:
```
abcdef
defabc
```
Выходные данные:
```
3
```

Программа вернула позицию, с которой начинается сдвиг.

## backtracking

> Алгоритм backtracking для решения задачи заполнения квадрата минимальным количеством квадратов меньших размеров.

Для сборки программы воспользуйтесь утилитой `make`. Для сборки тестирования &ndash; `make test`.

Запуск программы осуществляется следующим образом: `./program`. Прграмма принимает на вход размер большого квадрата. На выходе &ndash; количество квадратов, их позиция и размер. Например:
```
> ./program
```
Входные данные:
```
3
```
Выходные данные:
```
6
2 2 2
3 1 1
1 3 1
1 1 1
2 1 1
1 2 1
```

Для удобства использования реализован CLI-интерфейс. Для ознакомления необходимо ввести `./program --help`.

Помимо прочего, программа способна вычислять количество операций (запуск с ключом `-c` или `--counter`). Пример:

```
> ./program -c
```
Входные данные:
```
3
```
Выходные данные:
```
10
```

Помимо прочего, реализован скрипт на Python3, строящий график количества итераций от размера большого квадрата, рассматривая размеры, являющиеся простыми числами от 3 до 37. Запуск: `python3 research.py`

## pathfinding

> Жадный алгоритм и алгорит А* поиска путей в графе.

Для сборки программы воспользуйтесь утилитой `make`. Для сборки тестирования &ndash; `make test`.

Программа работает в двух режимах: алгоритм А* и жадный алгоритм.

Запуск алгоритма А* осуществляется следующим образом: `./program`. Прграмма принимает на вход начальную и конечную вершины, а затем список рёбер (вершины и вес). На выходе программа выдаёт минимальный путь. Например:
```
> ./program
```
Входные данные:
```
a d
a b 1
a c 3
a d 11
b c 2
b d 5
c d 1
```
Выходные данные:
```
acd
```

Запуск жадного алгоритма осуществляется следующим образом: `./program -g`или `./program --greedy`. Например:
```
> ./program --greedy
```
Входные данные:
```
a d
a b 1
a c 3
a d 11
b c 2
b d 5
c d 1
```
Выходные данные:
```
abcd
```

Для удобства использования реализован CLI-интерфейс. Для ознакомления необходимо ввести `./program --help`.
